<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="最近突然想了解一下浏览器的工作原理，于是跑到极客时间上面找到李兵老师的课程进行学习，于是有了这篇笔记，做笔记过程中，并没有完整记下来，只记录了自己觉得陌生重要的部分，如果想深入了解一下，大家可以去极客时间上面找到李兵老师的课程浏览器工作原理。">
<meta property="og:type" content="article">
<meta property="og:title" content="浏览器基础篇">
<meta property="og:url" content="http://example.com/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/index.html">
<meta property="og:site_name" content="CHJ &amp; HD">
<meta property="og:description" content="最近突然想了解一下浏览器的工作原理，于是跑到极客时间上面找到李兵老师的课程进行学习，于是有了这篇笔记，做笔记过程中，并没有完整记下来，只记录了自己觉得陌生重要的部分，如果想深入了解一下，大家可以去极客时间上面找到李兵老师的课程浏览器工作原理。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/1.png">
<meta property="og:image" content="http://example.com/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/2.png">
<meta property="og:image" content="http://example.com/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/3.png">
<meta property="og:image" content="http://example.com/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/4.png">
<meta property="og:image" content="http://example.com/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/5.png">
<meta property="og:image" content="http://example.com/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/6.png">
<meta property="og:image" content="http://example.com/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/7.png">
<meta property="og:image" content="http://example.com/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/8.png">
<meta property="og:image" content="http://example.com/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/9.png">
<meta property="og:image" content="http://example.com/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/10.png">
<meta property="og:image" content="http://example.com/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/11.png">
<meta property="article:published_time" content="2022-01-23T07:49:56.000Z">
<meta property="article:modified_time" content="2022-02-10T05:37:45.148Z">
<meta property="article:author" content="CHJ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/1.png">

<link rel="canonical" href="http://example.com/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>浏览器基础篇 | CHJ & HD</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="CHJ & HD" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CHJ & HD</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">前端攻城狮笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CHJ">
      <meta itemprop="description" content="Hello，大家好，欢迎大家来到我的博客网站，本人是一名前端学习者，也是一名前端爱好者，同时也是篮球球星哈登的粉丝，如果你有着跟我相同的爱好，或者你也喜欢哈登，希望能和你成为朋友，一起讨论共同的爱好，下面是我学习前端路上的一些笔记，希望对大家有帮助，同时，如果有错误，还望大家指出!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CHJ & HD">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          浏览器基础篇
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-23 15:49:56" itemprop="dateCreated datePublished" datetime="2022-01-23T15:49:56+08:00">2022-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-10 13:37:45" itemprop="dateModified" datetime="2022-02-10T13:37:45+08:00">2022-02-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>最近突然想了解一下浏览器的工作原理，于是跑到极客时间上面找到李兵老师的课程进行学习，于是有了这篇笔记，做笔记过程中，并没有完整记下来，只记录了自己觉得陌生重要的部分，如果想深入了解一下，大家可以去极客时间上面找到李兵老师的课程<a target="_blank" rel="noopener" href="http://gk.link/a/115Sf">浏览器工作原理<a>。</a></a></p>
<span id="more"></span>



<h3 id="浏览器工作原理"><a href="#浏览器工作原理" class="headerlink" title="浏览器工作原理"></a>浏览器工作原理</h3><h4 id="01-仅仅打开一个页面，为什么有多个进程"><a href="#01-仅仅打开一个页面，为什么有多个进程" class="headerlink" title="01|仅仅打开一个页面，为什么有多个进程"></a>01|仅仅打开一个页面，为什么有多个进程</h4><p>首先大家可以打开Chrome浏览器右上角的“选项”菜单，选择“更多工具”，点击“任务管理器”</p>
<p><img src="/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/1.png" alt="64273051510"></p>
<p>大家可以看到，这里启动了多个进程，至于原因，大家需要先跟着了解一下进程的概念</p>
<h5 id="什么是并行处理"><a href="#什么是并行处理" class="headerlink" title="什么是并行处理"></a>什么是并行处理</h5><p>计算机中的并行处理就是同一时刻处理多个任务，下面举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = 1 + 2;</span><br><span class="line">B = 20 / 5;</span><br><span class="line">C = 7 * 8;</span><br></pre></td></tr></table></figure>

<p>在编写代码的时候，我们可以把这个过程拆分为四个任务：</p>
<p><strong>任务1</strong>是计算A = 1+2</p>
<p><strong>任务2</strong>是计算B = 20/5</p>
<p><strong>任务3</strong>是计算C = 7*8</p>
<p><strong>任务4</strong>是显示最后的结果</p>
<blockquote>
<p>如果程序使用单线程来处理，那么这个程序需要分四步执行这四个任务</p>
</blockquote>
<blockquote>
<p>但是，如果程序采用的是多线程，那么只需要两步就可以完成这四个任务：第一步使用三个线程完成前三个任务，第二步使用一个线程显示最后的结果</p>
</blockquote>
<p>通过对比分析，我们可以发现，使用并行处理可以大大提升性能</p>
<h5 id="进程VS线程"><a href="#进程VS线程" class="headerlink" title="进程VS线程"></a>进程VS线程</h5><p>多线程可以并行处理程序，但是<strong>线程是不能单独存在的，它是由进程来启动和管理的</strong>，那进程又是什么呢？</p>
<p><strong>一个进程就是一个程序的运行实例</strong>，详细解释就是：启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个<strong>运行环境</strong>叫<strong>进程</strong>。</p>
<p><strong>线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率</strong></p>
<p>总结来说，进程与线程的关系有以下四个特点：</p>
<p><strong>1.进程中的任一线程出错，都会导致整个进程崩溃</strong></p>
<p><strong>2.线程之间共享进程中的数据</strong></p>
<p><strong>3.当一个进程关闭之后，操作系统会回收进程中所占用的内存</strong></p>
<p><strong>4.进程之间的内容相互隔离</strong></p>
<h5 id="目前多进程架构"><a href="#目前多进程架构" class="headerlink" title="目前多进程架构"></a>目前多进程架构</h5><p><img src="/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/2.png" alt="64273183201"></p>
<p>从图中可以看出，最新的Chrome浏览器包括：1个浏览器主进程，1个GPU进程，一个网络进程，多个插件进程，多个渲染进程</p>
<p><strong>浏览器进程：</strong>主要负责页面展示，用户交互，子进程管理，同时提供存储等功能</p>
<p><strong>渲染进程：</strong>核心任务是将HTML，CSS和JavaScript转换为可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都是运行在该程序中。出于安全考虑，渲染进程都是运行在沙箱模式下。</p>
<p><strong>GPU进程：</strong>其实，Chrome刚开始发布的时候是没有GPU进程的，而GPU进程的使用初衷是为了实现3DCSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器普遍的需求，最后，Chrome在其多进程架构上也引入了GPU进程。</p>
<p><strong>网络进程：</strong>主要负责页面的网络资源加载</p>
<p><strong>插件进程：</strong>主要是负责插件的运行，因为插件容易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</p>
<p>虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样带来了一些问题：</p>
<p><strong>更高的资源占用：</strong>每个进程都包含公共基础结构的副本，这就意味着浏览器会消耗更多的内存资源</p>
<p><strong>更复杂的体系结构：</strong>浏览器各模块之间的耦合度高，扩展性差，会导致现在的架构已经很难适应新的需求了</p>
<h4 id="02-TCP协议：如何保证页面文件能被完整送达浏览器"><a href="#02-TCP协议：如何保证页面文件能被完整送达浏览器" class="headerlink" title="02|TCP协议：如何保证页面文件能被完整送达浏览器"></a>02|TCP协议：如何保证页面文件能被完整送达浏览器</h4><blockquote>
<p>要想优化Web页面的加载速度，需要对网络有充分的了解。而理解网络的关键是对网络协议有深刻的认识，不管是使用HTTP还是WebSocket，他们都是基于TCP/IP的</p>
</blockquote>
<h5 id="一个数据包的“旅程”"><a href="#一个数据包的“旅程”" class="headerlink" title="一个数据包的“旅程”"></a>一个数据包的“旅程”</h5><p><strong>互联网，实际上是一套理念和协议组成的协议架构，</strong>其中，协议是一套众所周知的规则和标准，如果各方都同意使用，那么它们之间的通信将变得毫无障碍。</p>
<p>互联网中的数据是通过<strong>数据包</strong>来传输的，如果发送的数据很大，那么该数据会被<strong>拆分为很多小数据包</strong>来传输。</p>
<h5 id="1-IP：把数据包送达目的主机"><a href="#1-IP：把数据包送达目的主机" class="headerlink" title="1.IP：把数据包送达目的主机"></a>1.IP：把数据包送达目的主机</h5><p>数据包要在互联网上进行传输，就要符合<strong>网络协议</strong>（Internet Protocol，简称IP）标准，互联网上不同的在线设备都有唯一的地址，地址只是一个数字，这和大部分家庭收件地址类似，只要知道一个家庭的具体地址，就可以往这个地址发送包裹，物流系统也能把物品送到目的地。</p>
<blockquote>
<p>计算机的地址称为IP地址，访问任何网站，实际上就是你的计算机向另外一台计算机请求信息。</p>
</blockquote>
<p>那么如果想要把一个数据包从主机A发送给主机B，那么传输之前，数据包需要附加上主机B的IP地址信息，这样才能正确送达，另外，数据包还需要附加上主机A（也就是本机）的IP地址，有了这些信息，主机B才可以回复信息给主机A。这些<strong>附加的信息会被装进一个叫IP头的数据结构里</strong>。</p>
<p><img src="/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/3.png" alt="64273557786"></p>
<p>​                                       <strong>简化的IP网络三层传输模型</strong></p>
<ul>
<li>上层将含有“极客时间”的数据包交给网络层；</li>
<li>网络层再将IP头附在数据包上，组成新的IP数据包，并交给底层；</li>
<li>底层通过物理网络将数据包传输给主机B；</li>
<li>数据包被传输到主机B的网络层，在这里主机B拆开数据包的IP头信息，并将拆开来的数据部分交给上层；</li>
<li>最终，含有“极客时间”信息的数据包就到达了主机B的上层了</li>
</ul>
<h5 id="2-UDP：把数据包送达应用程序"><a href="#2-UDP：把数据包送达应用程序" class="headerlink" title="2.UDP：把数据包送达应用程序"></a>2.UDP：把数据包送达应用程序</h5><p>IP协议是非常底层的协议，只负责把数据包传送到对方电脑，但是对方电脑并不知道把数据包交给哪个程序。因此，需要基于IP上开发能和应用打交道的协议，最常见的是“<strong>用户数据包协议</strong>”（User Datagram Protocol），简称UDP。</p>
<p>UDP中最重要的信息是端口号，端口号其实是一个数字，<strong>每个想访问网络的程序都需要绑定一个端口号</strong>，通过端口号，UDP就能将指定的数据包发送给指定的程序了，和IP头一样，端口号也会被装进UDP头里面。UDP再通过端口号把数据包分发给正确的程序。</p>
<p><img src="/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/4.png" alt="64273693091"></p>
<p>​                        <strong>UDP网络四层传输模型</strong></p>
<ul>
<li>上层将含有“极客时间”的数据包交给传输层；</li>
<li>传输层会将UDP头附加在数据包上，将新数据包交给网络层；</li>
<li>网络层将IP头附加在数据包上，将新数据包交给底层</li>
<li>数据包被传输至主机B，网络层将数据包的IP头拆分，并将剩余数据送至传输层；</li>
<li>传输层解开UDP头，并识别出端口，将剩余数据交给对应端口号的程序；</li>
<li>对应应用程序获取数据，完成传输。</li>
</ul>
<blockquote>
<p>在使用UDP发送数据时，有各种因素会导致数据包出错，虽然UDP可以校验数据是否正确，但是对于错误的数据包，UDP并不提供重发机制，只是丢弃当前的包，而且UDP在发送之后也无法知道是否能达到目的地。</p>
</blockquote>
<p>虽说UDP不能保证数据可靠性，但是传输速度却非常快，所以UDP会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏。</p>
<h5 id="3-TCP：把数据完整地送达应用程序"><a href="#3-TCP：把数据完整地送达应用程序" class="headerlink" title="3.TCP：把数据完整地送达应用程序"></a>3.TCP：把数据完整地送达应用程序</h5><blockquote>
<p>基于UDP传输存在地问题，我们引入了TCP，TCP（Transmission Control Protocol，传输控制协议）是一种面向连接地、可靠的、基于字节流地传输层通信协议。</p>
</blockquote>
<p>相对于UDP，TCP有以下两个特点：</p>
<ul>
<li>对于数据包丢失情况，TCP提供重传机制</li>
<li>TCP引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整地文件</li>
</ul>
<p><img src="/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/5.png" alt="64274830565"></p>
<p>​                        <strong>TCP网络四层传输模型</strong></p>
<p>一个完整地TCP连接的生命周期包括了“<strong>建立连接</strong>”，“<strong>传输数据</strong>”和“<strong>断开连接</strong>”三个阶段</p>
<p><img src="/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/6.png" alt="64274838676"></p>
<ul>
<li>首先是连接阶段，这个阶段是通过“<strong>三次握手</strong>”来建立客户端和服务器之间的连接。TCP提供<strong>面向连接</strong>的通信传输。面向连接是指在数据通信开始前先做好两端之间的准备工作。三次握手指的是建立一个TCP连接时，客户端和服务器总共要发送三个数据包以确认连接的建立</li>
<li>其次，传输数据阶段，在该阶段，<strong>接收端需要对每个数据包进行确认操作</strong>，也就是接收端在接收到数据包以后，需要发送确认数据包给发送端。也就是说，如果发送端在发送数据包后，在一定时间内没有接收到接收端反馈的反馈信息，则认为数据包丢失，并触发重发机制。</li>
<li>最后，断开连接阶段，数据传输完毕之后，涉及到最后一个阶段的“<strong>四次挥手</strong>”，来保证双反都能断开连接。</li>
</ul>
<p>所以，TCP为了保证数据传输的可靠性，牺牲了数据包的传输速度，因为“三次握手”和“数据包传输校验机制”等，把传输过程中的数据包的数量增加了一倍。</p>
<h4 id="03-HTTP请求流程：为什么很多站点第二次打开速度会很快"><a href="#03-HTTP请求流程：为什么很多站点第二次打开速度会很快" class="headerlink" title="03|HTTP请求流程：为什么很多站点第二次打开速度会很快"></a>03|HTTP请求流程：为什么很多站点第二次打开速度会很快</h4><p>HTTP协议是建立在TCP连接基础上的，是一种<strong>允许浏览器向服务器获取资源的协议</strong>，是Web的基础，通常由浏览器发起请求，用来获取不同类型的文件，例如HTML文件、CSS文件、JavaScript文件、图片、视频等等。</p>
<h5 id="浏览器端发起HTTP请求流程"><a href="#浏览器端发起HTTP请求流程" class="headerlink" title="浏览器端发起HTTP请求流程"></a>浏览器端发起HTTP请求流程</h5><p>如果在浏览器地址栏里键入极客时间网站的地址：<a target="_blank" rel="noopener" href="http://time.geekbang.org/index.html%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E5%AE%8C%E6%88%90%E5%93%AA%E4%BA%9B%E5%8A%A8%E4%BD%9C%E5%91%A2%EF%BC%9F">http://time.geekbang.org/index.html，浏览器会完成哪些动作呢？</a></p>
<p><strong>1.构建请求</strong></p>
<p>首先，浏览器构建请求行信息，构建好后，浏览器准备发起网络请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP.1</span><br></pre></td></tr></table></figure>



<p><strong>2.查找缓存</strong></p>
<p>在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，<strong>浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。</strong></p>
<p>当浏览器发现请求的资源已经在浏览器中存有副本，它会拦截请求，返回该资源的副本，而不会再去源服务器重新下载。这样做的好处有：</p>
<ul>
<li>缓解服务器端压力，提升性能</li>
<li>对于网站来说，缓存是实现快速资源加载的重要组成部分</li>
</ul>
<p>当然，如果缓存查找失败，就会进入网络请求过程了</p>
<p><strong>3.准备IP地址和端口</strong></p>
<p>因为<strong>浏览器使用HTTP协议作为应用层协议</strong>，用来封装请求的文本信息；并使用TCP/IP作为传输层协议将它发到网络上，所以在HTTP工作之前，浏览器需要通过TCP与服务器建立连接。也就是说，<strong>HTTP的内容是通过TCP的传输数据阶段来实现的</strong></p>
<p><img src="/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/7.png" alt="64283509147"></p>
<p>​                        <strong>TCP和HTTP的关系</strong></p>
<ul>
<li>HTTP网络请求的第一步是做什么呢？结合上图看，是和服务器建立TCP连接。</li>
<li>那建立连接的信息都有了吗？之前，我们讲到，建立TCP连接的第一步就是准备IP地址和端口号</li>
<li>那如何获取IP地址和端口号呢？我们目前只有一个URL地址，我们是否可以利用URL地址来获取IP地址和端口号呢？</li>
</ul>
<p>由于网站的IP地址都很难记忆，所以都是使用域名（time.geekbang.org）来代替，在获取IP地址时，我们则需要使用<strong>DNS</strong>（域名系统）按照域名和IP地址的一一映射关系，得到相应的IP地址</p>
<p>而如果URL没有特别指明端口号，那么HTTP协议默认是80端口</p>
<p><strong>4.等待TCP队列</strong></p>
<p>Chrome有个机制，同一个域名同时最多只能建立6个TCP连接，超过6个请求则会进入排队等待状态，当然，如果少于6，则直接进入下一步。</p>
<p><strong>5.建立TCP连接</strong></p>
<p>……</p>
<p><strong>6.发送HTTP请求</strong></p>
<p>一旦建立了TCP连接，浏览器就可以和服务器进行通信了。</p>
<p><img src="/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/8.png" alt="64283593124"></p>
<p>首先浏览器会向服务器发送请求行，它包括了请求方法、请求URI（Uniform Resource Identifier）和HTTP版本协议</p>
<p>发送请求行，就是告诉服务器浏览器需要什么资源，最常用的请求方法是<strong>GET</strong>。另外一个常用的方法是<strong>POST</strong>，它用于发送一些数据给服务器，如果使用POST方法，那么浏览器还要准备数据给浏览器，这些数据通过请求体来发送。</p>
<p>在浏览器发送请求行之后，还要以请求头形式发送一些其他的信息，把浏览器的一些基础信息告诉服务器。比如浏览器所使用的操作系统、浏览器内核、当前请求的域名信息、浏览器端的Cookie等等。</p>
<h5 id="服务器端处理HTTP请求流程"><a href="#服务器端处理HTTP请求流程" class="headerlink" title="服务器端处理HTTP请求流程"></a>服务器端处理HTTP请求流程</h5><p><strong>1.返回请求</strong></p>
<p>一旦服务器处理结束，便可以返回数据给浏览器了。</p>
<p><img src="/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/9.png" alt="64283705741"></p>
<p>首先服务器会返回<strong>响应行</strong>，包括协议版本和状态码。</p>
<p>服务器会通过响应行的状态码来告诉浏览器它的处理结果。</p>
<p>常见的状态码：</p>
<ul>
<li><p>1**：信息，服务器收到请求，需要请求者继续执行操作</p>
<p><strong>100</strong>：Continue，继续，客户端应继续其请求</p>
<p><strong>101</strong>：切换协议，服务器根据客户端的的请求切换协议，只能切换到更高级的协议，例如，切换到HTTP的新版本协议</p>
</li>
<li><p>2**：成功，操作被成功接收并处理</p>
<p><strong>200</strong>：请求成功</p>
<p><strong>201</strong>：已创建，成功请求并创建了新的资源</p>
<p><strong>202</strong>：已接受，但未完成处理</p>
<p><strong>204</strong>：无内容，服务器成功处理，但未返回内容，也就是说服务器不需要返回信息，此状态代码的示例包括删除请求或请求是通过表单发送的</p>
</li>
<li><p>3**：重定向，需要进一步操作以完成请求</p>
<p><strong>301</strong>：永久重定向，请求的资源已被永久地移动到新URI，返回信息包括新                URI，浏览器会自动定向到新URI</p>
<p><strong>302</strong>：临时重定向，与301类似，但是资源只是临时被移动，客户端应继续使用原有URI</p>
<p><strong>304</strong>：未修改，所请求的资源未修改，服务器返回此状态码，不会返回任何资源</p>
</li>
<li><p>4**：客户端错误，请求包含语法错误或无法完成请求</p>
<p><strong>400</strong>：客户端请求的语法错误，服务器无法理解</p>
<p><strong>401</strong>：请求用户的身份认证</p>
<p><strong>403</strong>：服务器理解请求客户端的请求，但是拒绝执行此操作</p>
<p><strong>404</strong>：服务器无法根据客户端的请求找到资源</p>
<p><strong>408</strong>：服务器等待客户端发送的时间过长，超时</p>
<p><strong>409</strong>：当请求与资源的当前状态冲突时，发送状态码409，这通常是同时更新或版本相互冲突的问题，服务器完成客户端的PUT请求时可能返回此代码</p>
<p><strong>410</strong>：请求的资源不可再用，并且将不再可用</p>
</li>
<li><p>5**：服务器错误，服务器在处理请求的过程中发生了错误</p>
<p><strong>500</strong>：服务器内部错误，无法完成请求</p>
</li>
</ul>
<p>随后，服务器会返回<strong>响应头</strong>，响应头包括服务器自身的一些信息，比如浏览器生成返回数据的时间，返回的数据类型，以及服务器要在客户端保存的Cookie信息。</p>
<p>发送完响应头之后，服务器就继续发送<strong>响应体</strong>，通常，响应体包含了HTML的实际内容。</p>
<p><strong>2.断开连接</strong></p>
<p>通常情况下，一旦服务器向客户端返回了请求数据，他就要关闭TCP连接。不过，如果浏览器或者服务器在其头信息中加入了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:Keep-Alive</span><br></pre></td></tr></table></figure>

<p>那么TCP连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个TCP连接发送请求。<strong>保持TCP连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。</strong></p>
<p><strong>3.重定向</strong></p>
<p>当你在浏览器中打开<strong>geekbang.org</strong>后，会发现最终打开的页面地址是<code>http://www.geekbang.org</code></p>
<p>这两个URL之所以不一样，是因为涉及到了一个<strong>重定向操作</strong></p>
<p>不过这种跳转并不是必然的，就比如说，如果你打开了<code>https://12306.cn</code>，你会发现这个站点是打不开的，这是因为12306的服务器并没有处理跳转，所以必须要手动输入完整的<code>https://www.12306.cn</code>才能打开页面。</p>
<blockquote>
<p>在了解了HTTP的请求流程后，我们来看两个问题</p>
</blockquote>
<h5 id="1-为什么很多站点第二次打开速度会很快？"><a href="#1-为什么很多站点第二次打开速度会很快？" class="headerlink" title="1.为什么很多站点第二次打开速度会很快？"></a>1.为什么很多站点第二次打开速度会很快？</h5><p>第二次页面打开很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据。</p>
<p>从上面的介绍可以发现，<strong>DNS缓存</strong>和<strong>页面资源缓存</strong>这两块数据是会被浏览器缓存的，其中DNS缓存比较简单，就是在浏览器本地将对应的IP和域名关联起来。</p>
<p>下面来看看浏览器资源缓存：</p>
<p><img src="/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/10.png" alt="64283823380"></p>
<p>从上图的第一次请求可以看出，当服务器返回<strong>HTTP响应头</strong>给浏览器时，浏览器是通过响应头中的<strong>Cache-Control</strong>字段来设置是否缓存该资源。通常，我们需要为这个资源设置一个缓存过期时长：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control:Max-age=2000  //单位为秒</span><br></pre></td></tr></table></figure>

<p>这就意味着，在该缓存还未过期的情况下，如果再次请求该资源，就会直接返回缓存中的资源给浏览器。</p>
<p>如果缓存过期了，浏览器则会继续发起网络请求，并且在HTTP请求头中带上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match:&quot;4f80f-12n-1b1kl23na&quot;</span><br></pre></td></tr></table></figure>

<p>服务器收到请求头之后，会根据If-None-Match的值来判断请求的资源是否有更新。</p>
<ul>
<li>如果没有更新，则返回304状态码，相当于告诉服务器：这个缓存可以继续使用。</li>
<li>如果有更新，服务器就直接返回最新资源给浏览器</li>
</ul>
<blockquote>
<p>简要来说，很多网站第二次访问能够秒开，是因为这些网站把资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间，同时DNS数据也被浏览器缓存了。</p>
</blockquote>
<h5 id="2-登录状态是如何保持的？"><a href="#2-登录状态是如何保持的？" class="headerlink" title="2.登录状态是如何保持的？"></a>2.登录状态是如何保持的？</h5><ul>
<li>用户调用POST方法提交用户登录信息给服务器</li>
<li>服务器接收信息，验证用户登录信息是否正确，如果正确，会生成一段表示用户身份的字符串，并把该字符串<strong>种</strong>（在青训营，一个老师这么讲的，还挺生动的）到浏览器中（其实就是把该字符串写到响应头的Set-Cookie字段里，然后把响应头发送给浏览器）</li>
<li>浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应体里面有Set-Cookie字段，浏览器会把这个字段保存到本地。</li>
<li>当用户再次访问时，浏览器发起请求之前，会读取之前保存的Cookie数据，并把数据写进请求头里的Cookie字段里，然后浏览器再讲请求头发送给服务器。</li>
<li>服务器根据请求头的Cookie字段信息，判断该用户是否是已登录状态，并把生成的数据发送给浏览器</li>
</ul>
<h4 id="04-导航流程：从输入URL到页面展示，这中间发生了什么？"><a href="#04-导航流程：从输入URL到页面展示，这中间发生了什么？" class="headerlink" title="04|导航流程：从输入URL到页面展示，这中间发生了什么？"></a>04|导航流程：从输入URL到页面展示，这中间发生了什么？</h4><p><img src="/2022/01/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87/11.png" alt="64290743745"></p>
<p>​                        <strong>完整流程示意图</strong></p>
<p>这个过程可以大致描述如下：</p>
<ul>
<li>首先，浏览器进程接收到用户输入的URL请求，浏览器进程便将该URL转发给网络进程</li>
<li>然后，在网络中发起真正的URL请求</li>
<li>接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程</li>
<li>浏览器进程接收到网络进程的响应头数据之后，发送“提交导航”消息到渲染进程</li>
<li>渲染进程接收到“提交导航”消息之后，便开始准备接收HTML数据，接收数据的方式是直接和网络进程建立数据管道</li>
<li>最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”</li>
<li>浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态</li>
</ul>
<p>其中，用户发出URL请求到页面开始解析的这个过程，就叫做<strong>导航</strong></p>
<p><strong>详细描述：</strong></p>
<p><strong>1.用户输入</strong></p>
<p>当用户在地址栏中输入一个查询关键字时，地址栏会判断<strong>输入的关键字</strong>是<strong>搜索内容</strong>，还是<strong>请求的URL</strong>：</p>
<ul>
<li>如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的URL</li>
<li>如果判断输入内容符合URL规则，比如输入的是time.geekbang.org，那么地址栏会根据规则，把这段内容加上协议，合成为完整的URL，如<code>https://time.geekbang.org</code></li>
</ul>
<p>当用户输入关键字并键入回车之后，这意味着当前页面即将要被换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行beforeunload事件的机会，beforeunload事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单情况，因此用户可以通过beforeunload事件来取消导航，让浏览器不再执行后续工作</p>
<p>如果当前页面没有监听beforeunload事件，或者同意了继续后续流程，那么浏览器会进入一个加载状态（也就是我们经常看到一个小圈在那里转），此时页面显示的依然是之前打开的页面，因为需要等待提交文档阶段，页面内容才会被替换</p>
<p><strong>2.URL请求过程</strong></p>
<p>接下来，便进入了页面资源请求过程，这时，浏览器进程会通过进程间通信（IPC）把URL请求发送至网络进程，网络进程接收到URL请求后，会在这里发起真正的URL请求流程</p>
<p>首先，查看本地是否缓存了该资源，然后进行DNS解析，获取服务器IP地址，如果请求是HTTPS，那么还需要建立TLS连接</p>
<p>接下来就是利用IP地址和服务器建立TCP连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的cookie等数据附加到请求头中，然后向服务器发送构建的请求信息</p>
<p>服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。</p>
<p><strong>（1）重定向</strong></p>
<p>在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是301或者302，那么说明服务器需要浏览器重定向到其他URL。这时网络进程会从响应头的Location字段里面读取重定向地址。</p>
<p><strong>（2）响应数据类型处理</strong></p>
<p>在处理了跳转信息之后，浏览器是如何区分URL请求返回的数据类型的呢？</p>
<p>答案是：Content-Type，Content-Type是HTTP头中一个非常重要的字段，它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据Content-Type的值来决定如何显示响应体的内容。</p>
<p>不同的Content-Type的后续处理流程也截然不同。如果是下载类型，那么该请求会被提交给浏览器的下载管理器，同时该URL请求的导航流程就此结束。但如果是HTML类型，那么浏览器会继续进行导航流程。</p>
<p><strong>3.准备渲染流程</strong></p>
<p>默认情况下，Chrome会为每个页面分配一个渲染进程，也就是说，每打开一个新页面都会配套创建一个新的渲染流程。但是，在某种情况下，浏览器也会让多个页面直接运行在同一个渲染流程中。</p>
<p><strong>那么什么情况下多个页面会同时运行在一个渲染进程中呢？</strong></p>
<p>要解决这个问题，我们需要先了解什么是同一站点（same-site）。具体地讲，我们讲“<strong>同一站点</strong>”定义为<strong>根域名</strong>加上<strong>协议</strong>，比如下面三个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://time.geekbang.org</span><br><span class="line">https://www.geekbang.org</span><br><span class="line">https://www.geekbang.org:8000</span><br></pre></td></tr></table></figure>

<p>它们都是属于<strong>同一站点</strong>，因为它们的协议都是HTTPS，而且根域名也都是geekbang.org。</p>
<p>Chrome的默认策略是：每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而<strong>新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程</strong>。相反，新页面和当前页面不属于同一站点，那么浏览器进程会为新页面创建一个新的渲染进程。</p>
<p>渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，所以下一步就进入了提交文档阶段。</p>
<p><strong>4.提交文档</strong></p>
<p>所谓提交文档，就是指浏览器进程将网络进程接收到的HTML数据提交给渲染进程，具体流程如下：</p>
<ul>
<li>首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息</li>
<li>渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”</li>
<li>等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程</li>
<li>浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态</li>
</ul>
<p><strong>5.渲染阶段</strong></p>
<p>一旦文档被提交，渲染进程便开始页面解析和子资源加载了，一个完整的页面就生成了。</p>

    </div>

    
    
    

      <footer class="post-footer">

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/14/JavaScript_2/" rel="prev" title="JavaScript总结篇（2）">
      <i class="fa fa-chevron-left"></i> JavaScript总结篇（2）
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="next" title="计算机网络">
      计算机网络 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">浏览器工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#01-%E4%BB%85%E4%BB%85%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E5%A4%9A%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">01|仅仅打开一个页面，为什么有多个进程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86"><span class="nav-number">1.1.1.</span> <span class="nav-text">什么是并行处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8BVS%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.2.</span> <span class="nav-text">进程VS线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%AE%E5%89%8D%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84"><span class="nav-number">1.1.3.</span> <span class="nav-text">目前多进程架构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#02-TCP%E5%8D%8F%E8%AE%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%A1%B5%E9%9D%A2%E6%96%87%E4%BB%B6%E8%83%BD%E8%A2%AB%E5%AE%8C%E6%95%B4%E9%80%81%E8%BE%BE%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="nav-number">1.2.</span> <span class="nav-text">02|TCP协议：如何保证页面文件能被完整送达浏览器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E2%80%9C%E6%97%85%E7%A8%8B%E2%80%9D"><span class="nav-number">1.2.1.</span> <span class="nav-text">一个数据包的“旅程”</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-IP%EF%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%8C%85%E9%80%81%E8%BE%BE%E7%9B%AE%E7%9A%84%E4%B8%BB%E6%9C%BA"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.IP：把数据包送达目的主机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-UDP%EF%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%8C%85%E9%80%81%E8%BE%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.UDP：把数据包送达应用程序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-TCP%EF%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E5%9C%B0%E9%80%81%E8%BE%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.2.4.</span> <span class="nav-text">3.TCP：把数据完整地送达应用程序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#03-HTTP%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E7%AB%99%E7%82%B9%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%89%93%E5%BC%80%E9%80%9F%E5%BA%A6%E4%BC%9A%E5%BE%88%E5%BF%AB"><span class="nav-number">1.3.</span> <span class="nav-text">03|HTTP请求流程：为什么很多站点第二次打开速度会很快</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%E5%8F%91%E8%B5%B7HTTP%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B"><span class="nav-number">1.3.1.</span> <span class="nav-text">浏览器端发起HTTP请求流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%A4%84%E7%90%86HTTP%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B"><span class="nav-number">1.3.2.</span> <span class="nav-text">服务器端处理HTTP请求流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E7%AB%99%E7%82%B9%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%89%93%E5%BC%80%E9%80%9F%E5%BA%A6%E4%BC%9A%E5%BE%88%E5%BF%AB%EF%BC%9F"><span class="nav-number">1.3.3.</span> <span class="nav-text">1.为什么很多站点第二次打开速度会很快？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E7%9A%84%EF%BC%9F"><span class="nav-number">1.3.4.</span> <span class="nav-text">2.登录状态是如何保持的？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#04-%E5%AF%BC%E8%88%AA%E6%B5%81%E7%A8%8B%EF%BC%9A%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%8C%E8%BF%99%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.4.</span> <span class="nav-text">04|导航流程：从输入URL到页面展示，这中间发生了什么？</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CHJ</p>
  <div class="site-description" itemprop="description">Hello，大家好，欢迎大家来到我的博客网站，本人是一名前端学习者，也是一名前端爱好者，同时也是篮球球星哈登的粉丝，如果你有着跟我相同的爱好，或者你也喜欢哈登，希望能和你成为朋友，一起讨论共同的爱好，下面是我学习前端路上的一些笔记，希望对大家有帮助，同时，如果有错误，还望大家指出!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/642342217" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;642342217" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:642342217@qq.com" title="E-Mail → mailto:642342217@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CHJ</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : ,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
